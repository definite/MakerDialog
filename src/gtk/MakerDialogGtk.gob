requires 2.0.0

%alltop{
/*
 * Copyright © 2009  Red Hat, Inc. All rights reserved.
 * Copyright © 2009  Ding-Yi Chen <dchen at redhat.com>
 *
 *  This file is part of MakerDialog.
 *
 *  MakerDialog is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  MakerDialog is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with MakerDialog.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdlib.h>
#include <strings.h>
#include <glib.h>
#include <glib/gi18n.h>
#include <gtk/gtk.h>
#include <locale.h>
#include "../config.h"
#include "../MakerDialog.h"
#include "../MakerDialogGtk.h"
%}

%headertop{
/**
 * Gtk binding for MakerDialog.
 *
 * This module provides convenient function to build a Gtk dialog.
 */

#ifndef MAKER_DIALOG_GTK_GOB_H_
#define MAKER_DIALOG_GTK_GOB_H_
#ifndef WIDGET_ID_PREFIX
#define WIDGET_ID_PREFIX "Gtk"
#endif
#ifndef WIDGET_ID_SEPARATOR
#define WIDGET_ID_SEPARATOR "+"
#endif
%}

enum MAKER_DIALOG_GTK_PLACEMENT{
    NONE,
    LEFT,
    RIGHT,
    TOP,
    BOTTOM,
} MakerDialog:Gtk:Placement;

%{
#ifndef STRING_BUFFER_SIZE_DEFAULT
#define STRING_BUFFER_SIZE_DEFAULT 200
#endif

#include "MakerDialogGtk-def.c"
%}

class Maker:Dialog:Gtk from Gtk:Dialog{
    public gboolean vbox_homogeneous=FALSE;
    public gint hbox_spacing=2;
    public gint vbox_spacing=2;
    protected GtkWidget *dialog_notebook=NULL
    destroywith gtk_widget_destroy;

    private MakerDialog *mDialog=NULL;
    private GHashTable *widgetTable={g_hash_table_new_full(g_str_hash,g_str_equal, g_free, NULL)}
    destroywith g_hash_table_destroy;
    private GHashTable *normalizedValuesTable={g_hash_table_new_full(g_str_hash,g_str_equal, NULL, g_string_chunk_free_wrap)}
    destroywith g_hash_table_destroy;

    init(self){
    }

    public MakerDialogGtk *new (void) {
	Self *self = GET_NEW;
	return self;
    }

    public MakerDialogGtk *new_full (MakerDialogUi *dlgUi, GtkWindow *parentWindow, gboolean modal){
	MAKER_DIALOG_DEBUG_MSG(2,"[I2] MakerGtk:new_full(-,-,%s)",(modal)? "TRUE":"FALSE");
	Self *self = GET_NEW;
	gtk_window_set_title(GTK_WINDOW(self),dlgUi->mDialog->title);
	gtk_window_set_modal (GTK_WINDOW(self), modal);
	if (parentWindow){
    	    gtk_window_set_transient_for(GTK_WINDOW(self),parentWindow);
	    gtk_window_set_destroy_with_parent (GTK_WINDOW(self), TRUE);
	}else{
	    gtk_window_set_destroy_with_parent (GTK_WINDOW(self), FALSE);
	}
	gtk_window_set_type_hint (GTK_WINDOW(self), GDK_WINDOW_TYPE_HINT_DIALOG);
	self->_priv->mDialog=dlgUi->mDialog;

	int i;
	for(i=0;i<self->_priv->mDialog->buttonSpecCount;i++){
	    gchar *buttonText=NULL;
	    if (self->_priv->mDialog->buttonSpecs[i].buttonText){
		buttonText=(gchar *) self->_priv->mDialog->buttonSpecs[i].buttonText;
	    }else{
		switch(self->_priv->mDialog->buttonSpecs[i].responseId){
		    case MAKER_DIALOG_RESPONSE_NONE:
		    case MAKER_DIALOG_RESPONSE_REJECT:
		    case MAKER_DIALOG_RESPONSE_ACCEPT:
		    case MAKER_DIALOG_RESPONSE_DELETE_EVENT:
			break;
		    case MAKER_DIALOG_RESPONSE_OK:
			buttonText=GTK_STOCK_OK;
			break;
		    case MAKER_DIALOG_RESPONSE_CANCEL:
			buttonText=GTK_STOCK_CANCEL;
			break;
		    case MAKER_DIALOG_RESPONSE_CLOSE:
			buttonText=GTK_STOCK_CLOSE;
			break;
		    case MAKER_DIALOG_RESPONSE_YES:
			buttonText=GTK_STOCK_YES;
			break;
		    case MAKER_DIALOG_RESPONSE_NO:
			buttonText=GTK_STOCK_NO;
			break;
		    case MAKER_DIALOG_RESPONSE_APPLY:
			buttonText=GTK_STOCK_APPLY;
			break;
		    case MAKER_DIALOG_RESPONSE_HELP:
			buttonText=GTK_STOCK_HELP;
			break;
		    default:
			break;
		}
	    }
	    g_assert(buttonText);
	    GtkWidget *button=gtk_dialog_add_button(GTK_DIALOG(self),_(buttonText),self->_priv->mDialog->buttonSpecs[i].responseId);
	    self_widget_register(self, button, buttonText, "button",-1);
	}

	GNode *pageNode=g_node_first_child(self->_priv->mDialog->pageRoot);
	g_assert(pageNode);

	if ((strcmp((gchar *)pageNode->data,MAKER_DIALOG_CONFIG_NO_PAGE)==0 && g_node_n_children(self->_priv->mDialog->pageRoot)<=1)){
	    /* No notebook page. */
	    /* Add properties */
	    maker_dialog_page_foreach_property(self->_priv->mDialog, (gchar *)pageNode->data, maker_dialog_gtk_construct_ui_PropFunc, (gpointer) self);
	}else{
	    /* Add notebook pages */
	    if (!self->dialog_notebook){
		self->dialog_notebook=gtk_notebook_new();
		gtk_box_pack_start (GTK_BOX(GTK_DIALOG(self)->vbox), self->dialog_notebook, TRUE, TRUE, 0);
	    }
	    for(; pageNode!=NULL; pageNode=g_node_next_sibling (pageNode)){
		gchar *pageName=(gchar *) pageNode->data;
		GtkWidget *label=gtk_label_new(_(pageName));
		self_widget_register(self, label, pageName, "label", -1);
		GtkWidget *vbox=gtk_vbox_new(self->vbox_homogeneous,self->vbox_spacing);
		self_widget_register(self, vbox, pageName, "box", -1);
		gtk_notebook_append_page (GTK_NOTEBOOK(self->dialog_notebook), vbox,label);
		/* Add properties */
		maker_dialog_page_foreach_property(self->_priv->mDialog, (gchar *)pageNode->data, maker_dialog_gtk_construct_ui_PropFunc, (gpointer) self);
	    }
	}

	/* Add properties */
//	g_hash_table_foreach(self->_priv->mDialog->propertyTable, maker_dialog_gtk_construct_ui_GHFunc, self);

	/* Align labels */
	if (self->dialog_notebook){
	    for(pageNode=g_node_first_child(self->_priv->mDialog->pageRoot); pageNode!=NULL; pageNode=g_node_next_sibling (pageNode)){
		gchar *pageName=(gchar *) pageNode->data;
		self_align_labels(self, pageName, &self->_priv->mDialog->labelAlignment);
	    }
	}else{
	    /* No notebook page. */
	    self_align_labels(self, NULL, &self->_priv->mDialog->labelAlignment);
	}
	return self;
    }

    /*
     * Outbox: box that contain widget and label.
     */
    protected GtkWidget *outbox_and_label_new(self, GtkWidget *widget, MakerDialogPropertyContext *ctx, MakerDialogGtkPlacement labelPlacement){
	GtkWidget *box=NULL;
	switch(labelPlacement){
	    case MAKER_DIALOG_GTK_PLACEMENT_TOP:
	    case MAKER_DIALOG_GTK_PLACEMENT_BOTTOM:
		box=gtk_vbox_new(FALSE,self->vbox_spacing);
 		break;
	    case MAKER_DIALOG_GTK_PLACEMENT_LEFT:
	    case MAKER_DIALOG_GTK_PLACEMENT_RIGHT:
		box=gtk_hbox_new(FALSE,self->hbox_spacing);
		break;
	    default:
		break;
	}
	if (box){
	    self_widget_register(self, box, ctx->spec->key, "box",-1);
	    GtkWidget *label=gtk_label_new(_(ctx->spec->label));
	    self_widget_register(self, label, ctx->spec->key, "label",-1);
#ifdef HAVE_GTK_WIDGET_SET_TOOLTIP_TEXT
	    if (ctx->spec->tooltip){
		gtk_widget_set_tooltip_text (label,_(ctx->spec->tooltip));
	    }
#endif
	    switch(labelPlacement){
		case MAKER_DIALOG_GTK_PLACEMENT_TOP:
		case MAKER_DIALOG_GTK_PLACEMENT_LEFT:
		    gtk_box_pack_start (GTK_BOX(box), label, FALSE, FALSE, 0);
		    gtk_box_pack_start (GTK_BOX(box), widget, FALSE, FALSE, 0);
		    break;
		case MAKER_DIALOG_GTK_PLACEMENT_BOTTOM:
		case MAKER_DIALOG_GTK_PLACEMENT_RIGHT:
		    gtk_box_pack_end (GTK_BOX(box), label, FALSE, FALSE, 0);
		    gtk_box_pack_end (GTK_BOX(box), widget, FALSE, FALSE, 0);
		    break;
		default:
		    break;
	    }
	}
	return box;
    }

    protected GtkWidget *check_button_new(self, MakerDialogPropertyContext *ctx){
	GtkWidget *widget = gtk_check_button_new();
	self_widget_register(self, widget, ctx->spec->key, NULL,-1);

	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget),g_value_get_boolean(&ctx->value));
	g_signal_connect(widget, "toggled", G_CALLBACK(on_toggleButton_toggled_wrap),ctx);
	return widget;
    }

    protected GtkWidget *combo_box_new(self, MakerDialogPropertyContext *ctx){
	GtkWidget *widget=NULL;
	GtkListStore *listStore=gtk_list_store_new(2, MKDG_TYPE_STRING, MKDG_TYPE_STRING);

	gint i;
	gint index=-1;
	gchar *listKey_curr=maker_dialog_value_to_string(&ctx->value, NULL);
	GStringChunk *strChunk=g_string_chunk_new(STRING_BUFFER_SIZE_DEFAULT);
	g_hash_table_insert(self->_priv->normalizedValuesTable, (gpointer) ctx->spec->key, (gpointer) strChunk);

	for(i=0;ctx->spec->validValues[i]!=NULL;i++){
	    /* Add new item*/
	    gchar *listKey_tmp=maker_dialog_string_normalized(ctx->spec->validValues[i], ctx->spec->valueType);
	    gchar *listKey=g_string_chunk_insert_const(strChunk, listKey_tmp);
	    g_free(listKey_tmp);

	    listStore_append(listStore, listKey, maker_dialog_gtk_get_translation_string(ctx->spec->validValues[i], ctx->spec));
	    if (strcmp(listKey_curr,listKey)==0){
		index=i;
	    }
	}
	if (index<0 && !(ctx->spec->flags & MAKER_DIALOG_PROPERTY_FLAG_FIXED_SET)){
	    listStore_prepend(listStore, listKey_curr, listKey_curr);
	    index=0;
	}
	g_free(listKey_curr);

	if (ctx->spec->flags & MAKER_DIALOG_PROPERTY_FLAG_FIXED_SET){
	    widget=gtk_combo_box_new_with_model (GTK_TREE_MODEL(listStore));
	    GtkCellRenderer *renderer = gtk_cell_renderer_text_new();
	    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(widget), renderer, FALSE);
	    gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(widget), renderer,
		    "text", 1,
		    NULL);
	}else{
	    widget=gtk_combo_box_entry_new_with_model (GTK_TREE_MODEL(listStore), 1);
	}

	self_widget_register(self, widget, ctx->spec->key, NULL,-1);
	gtk_combo_box_set_active(GTK_COMBO_BOX(widget),index);

	g_signal_connect(widget, "changed", G_CALLBACK(on_comboBox_changed_wrap),ctx);
	return widget;
    }

    protected GtkWidget *entry_new(self, MakerDialogPropertyContext *ctx){
	GtkWidget *widget=gtk_entry_new();
	self_widget_register(self, widget, ctx->spec->key, NULL,-1);
	if (ctx->spec->max>=0){
	    gtk_entry_set_max_length(GTK_ENTRY(widget),ctx->spec->max);
	}
	gtk_entry_set_text(GTK_ENTRY(widget), g_value_get_string(&ctx->value));
	gtk_editable_set_editable (GTK_EDITABLE(widget),
		!(ctx->spec->flags & MAKER_DIALOG_PROPERTY_FLAG_FIXED_SET));

	g_signal_connect(widget, "activate", G_CALLBACK(on_entry_activate_wrap),ctx);
	return widget;
    }

    protected GtkWidget *radio_buttons_new(self, MakerDialogPropertyContext *ctx){
	GtkWidget *box=gtk_vbox_new(FALSE,self->vbox_spacing);
	self_widget_register(self, box, ctx->spec->key, "box",-1);
	GtkWidget *radio=NULL;
	GtkWidget *radioHead=NULL;
	gsize i;
	for(i=0;ctx->spec->validValues[i]!=NULL;i++){
	    const gchar *strPtr=(ctx->spec->flags & MAKER_DIALOG_PROPERTY_FLAG_HAS_TRANSLATION) ? _(ctx->spec->validValues[i]) : ctx->spec->validValues[i];
	    if (i==0){
		radio=radioHead=gtk_radio_button_new_with_label(NULL, strPtr);
		self_widget_register(self, radio, ctx->spec->key, NULL, -1);
	    }else{
		radio=gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(radioHead), strPtr);
		self_widget_register(self, radio, ctx->spec->key, NULL, i);
	    }
	    gtk_box_pack_start (GTK_BOX(box), radio, FALSE, FALSE, 0);
	    if (ctx->valueIndex==i){
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio), TRUE);
	    }else{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio), FALSE);
	    }
	    g_signal_connect(radio, "toggled", G_CALLBACK(on_radioButton_toggled_wrap),ctx);
	}

	GtkWidget *widget=gtk_frame_new(_(ctx->spec->label));
	gtk_container_add(GTK_CONTAINER(widget), box);
#ifdef HAVE_GTK_WIDGET_SET_TOOLTIP_TEXT
	if (ctx->spec->tooltip){
	    gtk_widget_set_tooltip_text (widget,_(ctx->spec->tooltip));
	}
#endif
	return widget;
    }

    protected GtkWidget *spin_button_new(self, MakerDialogPropertyContext *ctx){
	GtkAdjustment *gAdjust= GTK_ADJUSTMENT(gtk_adjustment_new (
		maker_dialog_value_get_double(&ctx->value),
		ctx->spec->min, ctx->spec->max, ctx->spec->step, ctx->spec->step*10, 0.0));
	GtkWidget *widget = gtk_spin_button_new (gAdjust, ctx->spec->step, ctx->spec->decimalDigits);

	self_widget_register(self, widget, ctx->spec->key, NULL,-1);
	g_signal_connect(widget, "value-changed", G_CALLBACK(on_spinButton_value_changed_wrap),ctx);
	return widget;
    }

    protected gboolean add_property_ui(self, MakerDialogPropertyContext *ctx){
	MAKER_DIALOG_DEBUG_MSG(3,"[I3] Gtk:add_property_ui(%s,-)",ctx->spec->key);

	GtkWidget *vbox=self_get_base_vbox(self, ctx->spec->pageName);
	g_assert(vbox);
	if (!(ctx->flags & MAKER_DIALOG_PROPERTY_CONTEXT_FLAG_HAS_VALUE)){
	    /* Use default value */
	    maker_dialog_set_value(self->_priv->mDialog, ctx->spec->key, NULL);
	}
	GtkWidget *widget=NULL;
	MakerDialogGtkPlacement labelPlacement=MAKER_DIALOG_GTK_PLACEMENT_LEFT;

	if (ctx->spec->validValues){
	    if (maker_dialog_has_all_flags(ctx->spec->flags, MAKER_DIALOG_PROPERTY_FLAG_PREFER_RADIO_BUTTONS| MAKER_DIALOG_PROPERTY_FLAG_FIXED_SET)){
		widget=self_radio_buttons_new(self, ctx);
		labelPlacement=MAKER_DIALOG_GTK_PLACEMENT_NONE;
	    }else{
		widget=self_combo_box_new(self, ctx);
	    }
	}else{
	    switch(ctx->spec->valueType){
		case MKDG_TYPE_BOOLEAN:
		    widget=self_check_button_new(self, ctx);
		    break;
		case MKDG_TYPE_INT:
		case MKDG_TYPE_UINT:
		case MKDG_TYPE_LONG:
		case MKDG_TYPE_ULONG:
		case MKDG_TYPE_FLOAT:
		case MKDG_TYPE_DOUBLE:
		    widget=self_spin_button_new(self, ctx);
		    break;
		case MKDG_TYPE_STRING:
		    widget=self_entry_new(self, ctx);
		    break;
		default:
		    break;
	    }
	}

	if (!widget){
	    return FALSE;
	}
	GtkWidget *outbox= self_outbox_and_label_new(self, widget, ctx, labelPlacement);
	if (outbox){
	    gtk_box_pack_start (GTK_BOX(vbox), outbox, FALSE, FALSE, 2);
	}else{
	    /* Widget has its own box */
	    gtk_box_pack_start (GTK_BOX(vbox), widget, FALSE, FALSE, 2);
	}
	return TRUE;
    }


    /**
     * align_labels:
     * @self: A MakerDialogGtk.
     * @pageName: Name of notebook page to be apply, can be NULL.
     * @xalign: x align of labels. 0.0f for LEFT, 0.5f for CENTER, 1.0f for RIGHT.
     * @yalign: y align of labels. 0.0f for TOP, 0.5f for CENTER, 1.0f for BOTTOM.
     *
     * Align labels for better dialog appearance.
     *
     * Labels that associate with value setting widget are stretched into same width.
     * If @pageName is not NULL, only the labels in the page are stretched,
     * otherwise, all labels will be stretched.
     *
     * Moreover, the horizontal and vertical alignment can set by @xalign and @yalign, respectively.
     */
    protected void align_labels(self, const gchar *pageName, MakerDialogAlignment *labelAlignment){
	gint currentMaxWidth=0;
	GNode *pageNode=maker_dialog_find_page_node(self->_priv->mDialog, (pageName)? pageName: MAKER_DIALOG_CONFIG_NO_PAGE);
	GNode *keyNode=NULL;
	GtkWidget *widget=NULL;
	GtkRequisition requisition;
	gchar *key=NULL;
	/* Calculate max label width */
	for(keyNode=g_node_first_child(pageNode); keyNode!=NULL; keyNode=g_node_next_sibling (keyNode)){
	    key=(gchar *)keyNode->data;
	    widget=self_get_widget(self,key,"label", -1);
	    if (widget){
		gtk_widget_size_request (widget,&requisition);
		currentMaxWidth=MAX(currentMaxWidth, requisition.width);
	    }
	}

	/* Set label width with currentMaxWidth */
	for(keyNode=g_node_first_child(pageNode); keyNode!=NULL; keyNode=g_node_next_sibling (keyNode)){
	    key=(gchar *)keyNode->data;
	    widget=self_get_widget(self,key,"label", -1);
	    if (widget){
		gtk_widget_set_size_request(widget, currentMaxWidth,-1);
		gtk_misc_set_alignment (GTK_MISC(widget),labelAlignment->x,labelAlignment->y);
	    }
	}
	gtk_widget_show_all(GTK_WIDGET(self));
    }

    public void destroy(self){
	//gtk_widget_destroy (GTK_WIDGET(self));
	g_object_unref (G_OBJECT(self));
    }

    /**
     * write_gconf_schemas_file:
     * @self: A MakerDialogGtk.
     * @filename: Filename for output.
     * @owner: Owner of the schemas.
     * @schemasHome: The "home direcory" of schemas.
     * @locales: Supported locales, use ';' as delimiter.
     * @returns: TRUE if succeed; FALSE otherwise.
     *
     * Output the parameters as GConf schemes file.
     */
    public gboolean write_gconf_schemas_file(self, const gchar *filename,
	    const gchar * owner, const gchar *schemasHome, const gchar *locales){
//        MAKER_DIALOG_DEBUG_MSG(2,"::output_gconf_schemes_file(%s)",filename);
//        FILE *outF=fopen(filename,"w");
//        if (outF==NULL){
//            MAKER_DIALOG_DEBUG_MSG(1,"::output_gconf_schemes_file(%s) file %s cannot be written!",
//                    filename,filename);
//            return FALSE;
//        }
//        xml_tags_write(outF,"gconfschemafile",XML_TAMKDG_TYPE_BEGIN_ONLY,NULL,NULL);
//        xml_tags_write(outF,"schemalist",XML_TAMKDG_TYPE_BEGIN_ONLY,NULL,NULL);
//        SchemasFileData sData;
//        sData.schemasHome=schemasHome;
//        sData.owner=owner;
//        sData.locales=locales;
//        sData.outF=outF;
//        g_ptr_array_foreach(self->_priv->propList,ctx_write_callback,&sData);
//        xml_tags_write(outF,"schemalist",XML_TAMKDG_TYPE_END_ONLY,NULL,NULL);
//        xml_tags_write(outF,"gconfschemafile",XML_TAMKDG_TYPE_END_ONLY,NULL,NULL);
//        if (fclose(outF))
//            return FALSE;
//        MAKER_DIALOG_DEBUG_MSG(2,"::output_gconf_schemes_file(%s) ... done.",filename);
	return TRUE;
    }

    public GValue *get_widget_value(self, const gchar *key){
	MAKER_DIALOG_DEBUG_MSG(3,"[I3] Gtk:get_widget_value(%s)",key);
	MakerDialogPropertyContext *ctx=maker_dialog_get_property_context(self->_priv->mDialog,key);
	if (!ctx){
	    /* Not found */
	    return NULL;
	}
	GtkWidget *widget=self_get_widget_by_key(self,key);
	if (!widget){
	    return NULL;
	}
	GValue *value=g_new0(GValue, 1);
	g_value_init(value,ctx->spec->valueType);
	if (ctx->spec->validValues){
	    if (maker_dialog_has_all_flags(ctx->spec->flags, MAKER_DIALOG_PROPERTY_FLAG_PREFER_RADIO_BUTTONS| MAKER_DIALOG_PROPERTY_FLAG_FIXED_SET)){
		gint iCount;
		for (iCount=0;ctx->spec->validValues[iCount]!=NULL;iCount++){}

		GSList *sList=gtk_radio_button_get_group(GTK_RADIO_BUTTON(widget));
		/* The head of list is the last one add to radio button */

		gint i=0,iSet=-1;
		while(sList){

		    if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(sList->data))){
			iSet= iCount-1-i;
			break;
		    }
		    sList=g_slist_next(sList);
		    i++;
		}
		MAKER_DIALOG_DEBUG_MSG(5,"[I5] Gtk:get_widget_value(-,%s) item %d activated", key, iSet);
		if (iSet>=0){
		    maker_dialog_value_from_string(value, ctx->spec->validValues[iSet], ctx->spec->parseOption);
		}else{
		    g_free(value);
		    return NULL;
		}
	    }else{
		GValue valTmp={0};
		g_assert(combo_get_active_value(GTK_COMBO_BOX(widget), &valTmp));
		maker_dialog_value_from_string(value, g_value_get_string(&valTmp), ctx->spec->parseOption);
		g_value_unset(&valTmp);
	    }
	}else{
	    switch(ctx->spec->valueType){
		case MKDG_TYPE_BOOLEAN:
		    g_value_set_boolean(value, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON(widget)));
		    break;
		case MKDG_TYPE_INT:
		case MKDG_TYPE_UINT:
		case MKDG_TYPE_LONG:
		case MKDG_TYPE_ULONG:
		case MKDG_TYPE_FLOAT:
		case MKDG_TYPE_DOUBLE:
		    maker_dialog_value_set_number(value, gtk_spin_button_get_value (GTK_SPIN_BUTTON(widget)));
		    break;
		case MKDG_TYPE_STRING:
		    g_value_set_string(value, gtk_entry_get_text (GTK_ENTRY(widget)));
		    break;
		default:
		    break;
	    }
	}
	return value;
    }

    /**
     * set_widget_value:
     * @self: A MakerDialogGtk.
     * @key: The key of a property.
     * @value: Value to be shown in widget.
     *
     * Set value for widget display.
     * However, the property value is not set.
     * Use apply_widget_value() to do it.
     * @see_also: apply_widget_value()
     */
    public void set_widget_value(self, const gchar *key, GValue *value){
	int index;
	MAKER_DIALOG_DEBUG_MSG(4,"[I4] Gtk:set_widget_value()");
	MakerDialogPropertyContext *ctx=maker_dialog_get_property_context(self->_priv->mDialog,key);
	if (!ctx){
	    /* Not found */
	    return;
	}
	GtkWidget *widget=self_get_widget_by_key(self,key);
	if (ctx->spec->validValues){
	    if (maker_dialog_has_all_flags(ctx->spec->flags, MAKER_DIALOG_PROPERTY_FLAG_PREFER_RADIO_BUTTONS| MAKER_DIALOG_PROPERTY_FLAG_FIXED_SET)){
		gint iCount;
		for (iCount=0;ctx->spec->validValues[iCount]!=NULL;iCount++){}

		gint i=iCount-1;
		GSList *sList=gtk_radio_button_get_group(GTK_RADIO_BUTTON(widget));
		/* The head of list is the last one add to radio button */
		GValue *val=g_new0(GValue, 1);
		g_value_init(val, ctx->spec->valueType);
		while(sList){
		    val=maker_dialog_value_from_string(val, ctx->spec->validValues[i], ctx->spec->parseOption);
		    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(sList->data),
			    (maker_dialog_value_compare(val, value, NULL)==0) ? TRUE: FALSE );
		    sList=g_slist_next(sList);
		    i--;
		    g_value_reset(val);
		}
		g_value_unset(val);
		g_free(val);
	    }else{
		index=combo_find_value_index(GTK_COMBO_BOX(widget), value, ctx->spec);
		gtk_combo_box_set_active (GTK_COMBO_BOX(widget),index);
	    }
	}else{
	    g_value_init(value,ctx->spec->valueType);
	    switch(ctx->spec->valueType){
		case MKDG_TYPE_BOOLEAN:
		    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(widget),g_value_get_boolean(value));
		    break;
		case MKDG_TYPE_INT:
		case MKDG_TYPE_UINT:
		case MKDG_TYPE_LONG:
		case MKDG_TYPE_ULONG:
		case MKDG_TYPE_FLOAT:
		case MKDG_TYPE_DOUBLE:
		    gtk_spin_button_set_value (GTK_SPIN_BUTTON(widget), maker_dialog_value_get_double(value));
		    break;
		case MKDG_TYPE_STRING:
		    g_value_set_string(value, gtk_entry_get_text (GTK_ENTRY(widget)));
		    break;
		default:
		    break;
	    }
	}
    }


    public GtkWidget *get_widget(self,
	    const gchar *widget_label, const gchar *widget_type, gint serial){
	gchar *id=widget_gen_id(widget_label, widget_type, serial);
	GtkWidget *widget=self_get_widget_by_id(self, id);
	g_free(id);
	return widget;
    }

    public GtkWidget *get_widget_by_key(self, const gchar *key){
	return self_get_widget(self,key,NULL, -1);
    }

    public GtkWidget *get_widget_by_id(self, const gchar *id){
	MAKER_DIALOG_DEBUG_MSG(4,"[I4] Gtk:get_widget_by_id(%s)",id);
	return (GtkWidget *) g_hash_table_lookup (self->_priv->widgetTable, id);
    }

    protected GtkWidget *get_base_vbox(self, const gchar *notebook_page_label){
	GtkWidget *ret=NULL;
	if (notebook_page_label){
	    ret=self_get_widget(self, notebook_page_label, "box", -1);
	}else if (self->dialog_notebook){
	    ret=self_get_widget(self, MAKER_DIALOG_CONFIG_NO_PAGE, "box", -1);
	}else{
	    ret=GTK_DIALOG(self)->vbox;
	}
	return ret;
    }

    protected void widget_register(self,  GtkWidget *widget,
	    const gchar *widget_label, const gchar *widget_type, gint serial){
	gchar *id=widget_gen_id(widget_label, widget_type, serial);
	g_hash_table_insert(self->_priv->widgetTable, id, widget);
	gtk_widget_set_name(widget, id);
	MAKER_DIALOG_DEBUG_MSG(4,"[I4] Gtk:widget_register(-,%s,%s) widget registered as %s",
		widget_label,(widget_type)? (widget_type) : "", id);
    }


}

%headertop{
#endif /* MAKER_DIALOG_GTK_GOB_H_ */
%}

